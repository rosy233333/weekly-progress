# 200行代码解析绿色线程原理

时间：2023/12/7

源资料：[https://www.zhihu.com/people/gengteng/posts](https://www.zhihu.com/people/gengteng/posts)

## 大致内容

该文章在用户态实现了轻量级线程（协程）。

其在用户态记录线程的id、栈、上下文（调用者保存的寄存器的值）、状态。

并且，在用户态实现一个调度器，调度这些线程。

使用修改rsp寄存器再`ret`的方式实现任务切换。

```Rust
#[derive(PartialEq, Eq, Debug)]
enum State {
    Available,
    Running,
    Ready,
}

struct Thread {
    id: usize,
    stack: Vec<u8>,
    ctx: ThreadContext,
    state: State,
}

#[derive(Debug, Default)]
#[repr(C)]
struct ThreadContext {
    rsp: u64,
    r15: u64,
    r14: u64,
    r13: u64,
    r12: u64,
    rbx: u64,
    rbp: u64,
}
```

## 关于内联汇编

由于文章较久远，之后Rust内联汇编的语法发生了改变，原有代码不再适用。因此在实验过程中遇到了一些困难，也总结了一些使用Rust内联汇编的经验。

可以参考这篇文章：[在 Rust 中使用内联汇编 (Inline assembly)](https://zhuanlan.zhihu.com/p/615148682)

内联汇编有两种，`asm!`和`global_asm!`。

当需要在函数中插入部分汇编代码时，使用`asm!`。其支持在汇编代码中使用Rust变量。

当需要在Rust中写一个纯汇编的函数时，使用`extern "C"`块来声明函数签名，然后用`global_asm!`来编写函数体，其需要在开头写上函数名作为标签。如下：

```Rust
use std::arch::global_asm;

extern "C" {
   fn my_asm_add(a: i32, b: i32) -> i32;
}

// a: edi, b: esi, 返回值: eax
global_asm! {"
    my_asm_add:
        mov eax, edi
        add eax, esi
        ret
"}
```

此时，函数参数和返回值的传递使用对应架构的传参规范，且需要自己维护栈帧。

当target为x86_64-unknown-linux-gnu时，内联汇编采用Intel语法。（即，目标操作数在前，源操作数在后；寄存器前面不需加"%"；使用"\[ \]"进行间接寻址）