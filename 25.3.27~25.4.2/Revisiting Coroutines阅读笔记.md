# 《Revisiting Coroutines》阅读笔记

时间：2025.4.2

## 我学到的

协程的定义和分类

既然这里说到，完全协程的表示能力是最高的，为何现在的大部分协程实现都使用了无栈协程？

## Introduction

### 协程的概念和分类

协程的概念在1960s被提出。Conway：协程是“饰演主程序的子程序”。

不过，（在当时）许多语言没有提供协程的支持。其原因可以部分地源于对协程没有清晰的定义和统一的视角。Marlin概括的协程的特征：

- 局部变量的值在连续的调用间保持。
- 程序返回视为任务暂停，程序调用视为任务继续。

其描述了协程的行为（保存状态），但不涉及协程的结构。因此可以按照实现方式，对协程进行三种分类：

- 控制流转移方式：对称协程和不对称协程
- 是否在其语言中视为一等对象（First-class Object）（一等对象：可以存入变量，可以作为函数参数和返回值）
- 实现是否有栈，决定了能否从嵌套协程中返回（不过，目前使用async-await语法的无栈协程是可以做到从嵌套协程中返回的。虽然这种嵌套返回的实质也是层层返回到最外层。）

一些适应特定用途的协程：例如生成器、迭代器等。但它们在可表示性（后文定义）上与一般协程不一样。

### 对协程研究兴趣下降的原因

1. **一等续体（First-class Continuation）**：具有明确定义、可以用于实现许多种功能（如生成器、异常处理、backtracing、源代码级多任务、协程）的控制流抽象。其导致了协程作为**通用控制抽象**的研究兴趣近乎终结。但该特性在许多语言中未提供。

[first-class continuation介绍]("./first-class continuation介绍")

2. 线程称为多任务实现的事实标准，也导致了对协程作为**多任务实现方式**的关注下降。

### 本文的目标：呼吁对协程的重新关注

协程可以作为与过程式编程语言适配的、实现和理解简单的强大的控制抽象。

本文证明：

1. 一等有栈协程（称为完全协程）具有和单次续体（One-shot Continuation）、单次限定续体（One-shot Delimited Continuation）相同的表示能力。（注：One-shot continuation几乎可以所有应用中替换标准Continuation）
2. 对称协程和非对称协程的表示能力相同。不过处于方便的考虑，选用不对称协程做演示。

### 文章结构

第2章：协程的分类，及各个类型协程的可用程度对比

第3章：不对称完全协程的形式化定义

第4章：使用不对称完全协程实现的几种控制行为示例

第5章：证明不对称完全协程的表达能力与对称完全协程、单次续体、单次限定续体相同。

第6章：总结

## 协程的分类

### 控制流转移方式

对称协程：使用单个yield操作，在对称协程之间转移控制，转移目标不确定。协程间为平级关系。

非对称协程：使用call操作建立协程间的调用关系，yield操作一定返回到该协程的调用者。协程间为树状的调用关系。

迭代器和生成器就可以看作一种非对称协程。

对称协程和非对称协程具有相同的表达能力。但在使用的难易度上，非对称协程由于具有确定的控制流转移目标，因此更简单。

### 是否为一等对象

受限协程：在语法层面受限、无法被程序员直接使用。例如CLU中的迭代器，只能在for循环内部使用，且每次循环调用一次。（不过，Rust中的迭代器也是一等对象了。）Icon的生成器具有较宽松的限制，但同样不是一等对象。

一等协程：作为一等对象的协程。

### 是否有栈

实现是否有栈，决定了能否从嵌套协程中原地返回和原地恢复。

如果需要在无栈协程中，从嵌套协程中返回，则需要将每一层都实现为无栈协程，嵌套返回。（这里提到的就是async-await语法的问题：async的“传染性”）

### 完全协程

完全协程就是有栈、作为一等对象的协程。

因为非对称协程更方便（且非对称协程支持“调用了不支持协程的其它语言代码”的环境），因此后文讨论非对称协程。

## 非对称完全协程的定义

### 协程操作符

- `create: fn(Fn(T) -> T) -> Coroutine`：创建（但不立即执行）新协程
- `resume: fn(Coroutine, &mut T)`：启动或继续协程的运行，协程暂停或结束时，该函数返回。已结束的协程不能再`resume`。
- `yield: fn(T)`：暂停协程运行。如果要结束协程的运行，则正常使用`return T`。

主从协程的数据传输：

- `yield`的第二参数，在第一次调用某协程时，作为传入协程主函数的参数。
- 协程暂停或结束时，`yield`或`return`传递的返回值放入`resume`的第二参数中。

### 操作语义

#### 核心语言的定义

一个使用传值调用（call by value）的、附加了赋值语句的λ演算。该语言包含：

- 标签：l和一系列常数值
- 变量（x）
- 函数定义（λ演算中的“抽象”）
- 函数调用（λ演算中的“应用”）
- 赋值语句
- 条件语句
- 适用于标签的取等表达式
- nil取值

`e → l | x | λx · e | e e | x := e | if e then e else e | e = e | nil`

表示值的表达式：标签、函数、nil：`v → l | λx · e | nil`

`FV(e)`：`e`中的自由变量集合；`LB(e)`：`e`中的标签集合

`store`（用`θ`表示）：将变量和标签映射到值，代表对一些变量和标签（应该类似全局变量）的赋值：`θ : (variables ∪ labels) → values`。用于实现有副作用的函数。

`FV`和`LB`可以表示`store`中的自由变量和标签。

#### 核心语言的求值

求值上下文（`C`）：用于定义下一步需要求值的子表达式。在该核心语言中，从右向左求值。

![alt text](image-1.png)

各式含义：

1. 对变量求值，获得其在`store`中的值。
2. 对“应用”（函数调用）的求值：先在`store`中创建一个新变量`z`，将其赋值为`v`，再将`z`代入函数。
3. 赋值的求值，就是对`store`中的变量进行操作。
4. if的求值
5. if的求值
6. 取等运算的求值
7. 取等运算的求值

（`[z/x]`代表用`z`替换`x`；`[z←v]`代表将v赋值给z）

表达式或程序`e`求值为`v`，记作`e ⇓ v`（`〈e, θ0〉 ∗ ⇒ 〈v, θ 〉`），`θ0`为空`store`，`θ`为任意`store`。

#### 语法糖

`let x = e1 in e2`：`(λx · e2) e1`（`x`可能在`e2`中作为自由变量）

`e1; e2`：`(λx · e2) e1`（`x`在`e2`中不是自由变量）

优先级：标签（见后文） < `let` < 分号 < 其它操作符

例如，`let x = e1 in x := e2; e3`的运算顺序为`let x = e1 in ((x := e2); e3)`

#### 协程的表示

扩展表达式的范围：增加了带标签的表达式，以及各个协程运算符：`e → ... | l: e | create e | resume e e | yield e`。

使用标签代表协程，使用标签表达式代表正在运行的协程。

协程的求值上下文：

`C → ... | create C | resume e C | resume C v | yield C | l: C`

分为完整上下文和子上下文。子上下文即为不包含带标签上下文的上下文，其代表调用关系最内层的协程。

![alt text](image-2.png)

各式含义：

8. 创建协程。在`store`中创建新标签l代表被创建的协程，然后将该语句求值为l。
9. 运行协程。将本句求值为一个代表相应协程的带标签表达式，并且传入协程所需的参数。（因此，继续求值本句就相当于进入协程。）将协程对应的标签赋值为`nil`，避免该协程被重复启动。
10. 暂停协程。首先，本语句需要带标签（代表在协程中），且需要带有协程内的求值上下文。将本句求值为值`v`。（因此，继续求值本句相当于回到主执行流。）并将标签`l`赋值为协程当前的求值上下文。
11. 标签不会影响求值。同时，这句代表了协程的结束。结束时会保持标签`l`取值为`nil`，从而防止协程再次启动。

## 使用非对称完全协程编程

先在Lua语言中实现完全非对称协程，在使用其实现多种控制结构。

### Lua中非对称完全协程的实现

Lua是一个动态类型、词法作用域、自动内存管理的轻量级脚本语言。在当时，与许多提供受限协程的语言不同，Lua提供了对非对称完全协程的支持。

[词法作用域介绍](https://www.freecodecamp.org/chinese/news/javascript-lexical-scope-tutorial/)

Lua中，函数是一等对象。`function foo(x) ... end`：`foo = function (x) ... end`

Lua的`table`：用关联数组实现，可以用任何值来索引。用`table`可以实现数组、集合、对象等。甚至提供了`a.name`：`a["name"]`的语法糖。

Lua提供的协程符合第3章中的非对称完全协程定义。

`coroutine.wrap`函数：创建新协程；其返回值为一个函数，该函数在被调用时，resume该协程。

在第三章的语言中定义`wrap`：`wrap = λ f · let l = create f in λx · resume l x`

`coroutine.yield`函数：与第三章的`yield`功能相同。

### 生成器

示例实现了遍历二叉树的迭代器。能够在嵌套协程中原地返回的特性，为该迭代器的实现提供了方便。

![alt text](image-3.png)

### 面向目标编程

将需要解决的问题分解为一系列替代目标的逻辑或，再将每个替代目标分解为一系列子目标的逻辑与。

该编程范式被应用于模式匹配问题和类Prolog查询中。

协程实现面向目标编程：

- 主协程作为主目标，将主协程包裹在循环中重复调用
- 替代目标的逻辑或：一个轮流返回其替代目标的结果的子协程。
- 子目标的逻辑与：对第一个子目标迭代，获得成功时再执行下一个子目标

示例：实现模式匹配。

要匹配的模式：`("abc"|"de")."x"`

![alt text](image-4.png)

![alt text](image-5.png)

![alt text](image-6.png)

注意：`prim`、`alt`、`seq`都是协程中的函数。

### 协作式多任务

在协作式多任务中，多个任务如何交织运行是确定性的，同步访问的机制也可以降到最少。因此，在时延不敏感的系统中，可以使用协作式多任务。

不过，协作式多任务也会遇到公平性问题，因为任务完全可以执行很长时间再让出。此外，性能问题和饥饿条件也难以复现，因此编程者可能难以确定何处插入让出语句更合适。同时，如果某个任务调用了阻塞操作，则整个线程都会被阻塞。因此，需要调用非阻塞式接口。

用户级多任务中，因为多个任务需要协作完成同一项任务，因此公平性问题可以得到缓解。

协作式多任务的实现：

![alt text](image-7.png)

其中，`table.remove()`可以移除元素后，让之后的元素前移填补缺口；

## 表示其它控制结构

表示能力的形式化定义：

![alt text](image-8.png)

### 对称协程

对称协程的操作：`create`和`transfer`。

`transfer`的第二参数：传给其唤醒的协程的数据。

用非对称协程实现对称协程：在一个主循环内轮询所有协程，协程和主循环即为非对称协程关系。

### 单次续体

单次续体的操作：`call1cc`（捕获续体）、`throw`（运行续体）

`throw`不是由程序员使用的，而是由`callcc/call1cc`在求值过程中生成的。

![alt text](image-9.png)

上文`callcc`复制了当前上下文（即续体），可能会违背单次运行的约束。为了实现单次限制，可以将当前续体存放在标签中，运行一次后就将该标签置空。

![alt text](image-11.png)

当单次续体被捕获时，当前栈被捕获，且对接下来执行的代码分配一个新的栈帧。当该续体执行时，丢弃当前栈，恢复到之前捕获的栈帧。

上文的情境中，捕获栈的过程类似于创建并执行一个子协程；执行续体的过程类似于从子协程返回父协程。

### 单次子续体

单次子续体是单次限定续体的一种。捕获的续体仅到当前函数末尾。

![alt text](image-12.png)

19. spawn的语义：为表达式v加标签（代表子过程），将controller和标签传入其中。
20. 当子过程完成时，将返回值传回spawn的调用点
21. 调用controller，创建子续体。需要语句标签与controller标签相同才能调用。

增加单次限制：

![alt text](image-13.png)

![alt text](image-14.png)

## 总结

协程研究遇冷，内因：没有清晰的定义；外因：单次续体的线程的广泛应用。

当前协程的研究兴趣提升，两个使用场景：代替多线程的协作式多任务；迭代器、生成器等受限协程。

本文的工作：对协程进行清晰的分类；明确定义了完全协程；证明了完全协程的表示能力与单次续体相同。

本文的局限：不涉及跨语言调用；不涉及性能的进一步讨论；（使用本文的实现方式，使用协程实现续体性能较高。用续体实现协程性能较低。）；没有对负面情况进行证明（例如，非完全协程不能实现单次续体；完全协程无法实现多次续体）



