# RCU项目总结文档

## 开发过程

### 2023.11.21~2023.11.27 学习阶段

学习了解RCU的基本知识，寻找Rust语言中的RCU实现，以及Alien OS中对锁的使用。

### 2023.11.28~2023.12.4 开发阶段

从Rust的各种RCU实现中，选择了[rcu-clean](https://docs.rs/rcu-clean/latest/rcu_clean/)，移植进[kernel-sync](https://github.com/os-module/kernel-sync)模块。

对其进行包装，以提供和原有的RwLock相似的接口。

### 2023.12.5之后 收尾阶段

向kernel-sync模块提交pull request并被接受。

调研了一些对RCU的测试方案，发现都很难应用于kernel-sync中的RCU。

撰写总结文档。

## 对RCU的总结

RCU（Read, Copy, Update）是一种允许单个写者和多个读者同时访问的数据结构，在写者数量少、读者数量多时有更好的性能。它可以应用于单个元素，也可以应用于链表。

RCU的设计思路如下：当写者需要修改数据时，不是直接在原数据上修改，而是创建其副本，在副本上修改。修改完成后，原子地将指向原数据的指针修改为指向修改后的副本。因此，在指针修改前，读者仍可以读到原数据；指针修改后，读者读到的就是修改后的数据。保证读者的读取不被阻塞。当所有读取原数据的读者均结束读取时（有读者正在读取原数据的期间被称为宽限期（grace period）），写者将原数据的内存释放，不会造成内存泄漏。

RCU实现的关键，在于写者对宽限期的判断，即是写者何时可以安全地释放原数据占用的空间。

RCU最经典的实现，用于不支持抢占的系统。当读者在读RCU时，它关闭中断，读取完成后再启用中断，使得读取期间无法切换到其它任务。写者更新指针后，其请求操作系统将自己调度到每个CPU内核上各一次。由于读者读RCU期间无法调度，写者需要等待读者读取完成后才能调度到读者所在的CPU内核上。因此，在经过一轮调度后，已经可以确定读原数据的读者均已读取完成，可以安全地释放空间。

## 移植RCU工作中的收获

在Alien OS中实现RCU机制，有以下几个难点：

1. Rust语言严格的所有权机制为数据的读写和释放产生了困难。
2. Alien OS将内核同步机制放在了外部模块中，只能通过特定的`LockAction`调用内核机制，为RCU使用内核机制的实现带来了困难。
3. RCU当前使用Rust语言的已有实现都不太完善。

比较了多个Rust实现的RCU后，最后考虑了`rcu-clean`。这个库在Rust的多种智能指针，`Arc`、`Box`和`Rc`上实现了RCU。然而，它没有自动检测宽限期并释放空间的机制，需要手动调用`clean()`方法来清理数据的旧版本。

我在这个库的`ArcRcu`基础上修改，因为它可以保证数据在线程间共享的安全性。在这之上，实现旧版本数据的自动释放。

在Paul E. McKenney的《深入理解并行编程》（*Is Parallel Programming Hard, And, If So,
What Can You Do About It?*
）的`“Toy” RCU Implementations`章节，我阅读了几种不同的RCU实现，最终选择了其中利用引用计数机制检测宽限期的一种实现，因为它较简单，且不依赖内核机制。它使用一个长度为2的引用计数数组来维护引用计数。通过在更新指针时切换引用计数的下标，可以使不同版本的数据使用不同的引用计数，使指针更新后开始读的读者不会影响到写者的宽限期。有这样的宽限期检测机制，我在`RcuLockWriteGuard`的`drop()`方法中，增加了等待宽限期结束和调用`clean()`清理旧版本的代码。

虽然，在RCU中增加引用计数在某种程度上违背了RCU的初衷，即作为引用计数的一种改进方法。但在Rust语言中，使用线程安全的`Arc`本身就使用了引用计数，在此基础上增加基于引用计数的RCU，应该不会对性能影响太大。