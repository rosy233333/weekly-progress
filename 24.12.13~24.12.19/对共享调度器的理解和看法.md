# 对共享调度器的理解与看法

## 当前情况

已有实现：赵方亮学长的COPS软件调度器和TAIC硬件调度器

正在实现：将TAIC应用于AsyncOS中，实现共享调度器；在AsyncOS中实现同步异步统一的函数调用和系统调用接口。

## 意图解决的问题（指标，调度的时间尺度达到微秒级）

### 线程与协程

#### 问题

在内核中引入协程，原因在于：

1. 系统内核具有处理I/O请求的需求，方便协程的应用（没有讲现在的不足）
2. TAIC要求系统支持协作式调度（没有必然联系）

但线程与协程具有各自的优势，线程具有更高的实时性，协程具有更低的开销。因此需要实现线程与协程的统一。（需要增加前提）

而两者统一的障碍为：两者在语法层面具有区别，接口上难以统一。（跟调度是没有太大的关系，更多是从编程语言的角度）

#### 实现

在当前实现AsyncOS中，内核使用可抢占的协程，其在正常运行期间以协程方式保存上下文，被抢占时以线程方式保存上下文。

AsyncOS还使用了同时兼容同步和异步的接口，使用`feature`确定使用同步实现还是异步实现，并将两种实现封装在一个函数中。

<!-- ### 中断与IPC

#### 问题

处理I/O任务时，中断方式由于当前任务不断被中断而影响了吞吐量，而轮询方式导致了CPU的空转。这一问题来源于CPU与外设的信息不对等：在中断方式中，中断携带了I/O任务完成的时间信息，但不知道哪个任务与该I/O任务关联；轮询方式中，CPU知道任务和I/O任务的关联信息，但不知道I/O任务何时完成。

#### 解决

因此，TAIC（任务感知的中断控制器）硬件集成任务调度与中断管理的功能，在硬件中维护任务的就绪队列和中断阻塞队列，中断到来时，直接将中断阻塞队列中的任务放回就绪队列中供CPU调度运行。CPU采用基于协程的协作式调度，不会直接响应中断，而是从TAIC中获取任务（这些任务可能是中断处理程序）。在稍微降低实时性的情况下提高了性能。

当前，TAIC还增加了IPC的支持，一个进程可以通过TAIC向另一个进程发送软件中断，接收方的处理流程与处理外部中断类似。 -->

### 内核态与用户态

#### 问题

**用户程序有使用用户态线程或协程的需求，但内核无法感知用户态的线程或协程。**

解决的问题要与最终的目标结合

#### 解决

COPS实现了内核态和用户态统一的协程调度机制。

使用vDSO将内核的协程调度系统（vDSO）共享到用户态，使用户程序可以直接使用它运行用户态协程。

内核使用“切换协程”对应一个用户进程，切换协程的优先级等于用户进程内协程的最高优先级（使用位图确定最高优先级）。

## 我的看法和改进方向

<!-- ### 1. 整合中断和协作式任务调度功能的TAIC现在是硬件实现，能否使用软件实现类似的功能？

因为就绪队列本来就常使用软件实现，因此此处更多考虑其处理外部中断和IPC的功能。

对于外部中断处理，需要在CPU的中断处理函数中将中断队列的任务移入就绪队列，而中断队列中的任务为处理中断的实际逻辑。这样的方式类似于[延后中断](https://arthurchiao.art/blog/linux-irq-softirq-zh/)。在实现中，形式中断处理函数可以简化到什么程度？其工作为从一个队列中拿出一个值放入另一个队列，能否使用汇编完成，以尽可能简便、且占用尽量少的寄存器（从而减少需要保存的中断上下文）？

对于IPC，使用软件实现的TAIC机制，则不再需要发出中断，而只需要进行对应的任务入队操作就行。

此外，还有创新性的问题：在硬件中整合外部中断处理、任务调度和IPC具有创新性，但在软件中实现类似的机制似乎创新性不足，因为它并未根本改变中断的处理方式。

### 2. TAIC为协作式调度设计，而AsyncOS里支持协作式和抢占式两种调度方式，这种调度环境是否与TAIC适配？

如果在TAIC中存储当前任务优先级，则其可以在就绪队列变化时可以判断是否需要抢占。如果需要抢占，可以向CPU发送一个中断，该中断专门用于触发抢占。这样应该可以实现基于TAIC的抢占式调度。

这样的实现如何影响性能？中断和抢占的引入确实会带来一些性能损失，不过可以使用AsyncStarry中的方式，使中断时保存的Trap上下文直接作为任务上下文，从而降低一些性能的损失。如果与普通的中断方式进行比较，则该方式只会在需要抢占时才会发送中断，降低了中断的频率，因此理论上应该依然具有性能优势。 -->

### 3. 用户态任务与内核态任务的统一调度问题

一般来说，任务分为内核态任务和用户态任务，分别在内核态和用户态进行创建和管理。对于系统内核，其任务均为内核态任务；对于用户进程，其内部可能具有多个内核态任务，也可能具有多个用户态任务。用户态任务位于内核态任务之上，用户态任务对内核不可见。（内核和所有进程的）内核态任务运行在内核调度器上，而用户态任务运行在进程自身的调度器上。

AsyncOS现在将内核态任务统一放置在内核调度器中，无论其属于系统内核还是某个用户进程。其用户运行时通过TAIC提供了用户态任务和批量系统调用的支持，并在内核态添加了相应支持。

共享调度器的目标之一是：进程内（可以是内核态，也可以是用户态）的线程和协程调度是在用户态进行的，而进程间的调度是在内核进行的。在同一个进程的用户态任务间切换，本就在用户态进行。但如果要实现在同一个进程的内核态任务间切换也可在用户态完成，则具有以下难点：

- 这样的切换，虽然切换前后位于相同的地址空间，但其中需要修改一些内核态数据结构的值（例如当前任务），而将这些值直接暴露到用户态是不安全的。

**不过，考虑到使用了多内核态线程的用户进程是为了达成利用多核的目的，则可以通过避免在同一个CPU核心上出现同一进程的多个内核态任务来达到该目标：**（thread-per-core）

在任务与核心关系相对固定的情况：

spawn

- 在进程试图创建内核态任务时，将其优先分配到没有运行该进程的CPU核心
- 如果所有核心上都有该进程的内核态任务，则改为创建用户态任务

在任务与核心关系相对松散的情况：

- 当CPU核心从调度器获得任务时，同一进程只允许一个内核态任务在其上允许
- 如果该进程的内核态任务数量等于核心数量，则改为创建用户态任务

实现该方案，需要用户态任务调度机制和内核态任务调度机制的紧密配合。

任务状态图：

创建到就绪：spawn
就绪到运行：fetch
就绪到阻塞：***
阻塞到就绪：***
