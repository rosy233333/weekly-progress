# 无锁链表与垃圾回收

参考资料：

[垃圾回收机制与无锁化编程（Garbage Collection and Lock-Free Programming）](https://cloud.tencent.com/developer/article/1660995)

查询当前链表bug的解决方案时，发现我遇到的问题，是无锁编程已研究得比较多的问题：垃圾回收问题。

**大部分无锁数据结构都依赖于垃圾回收机制。** 因为如果不释放被删除的节点，则会导致内存泄漏；如果在删除节点后立即主动释放它，则其它线程可能仍有可能访问到该节点，导致use after free问题；被释放的节点可能重新插入数据结构中，而不被正在访问该节点的其它线程所知，导致ABA问题。因此，需要通过垃圾回收机制，在节点不再会被访问的合适时机将其回收。

在我们用于堆分配器的无锁链表中，需要在删除节点后 **完全获得该节点的所有权** （也就是保证其它线程不会再访问到该节点），再将该节点对应的内存分配出去。这与垃圾回收机制的判断标准类似。

## 垃圾回收机制

基于epoch：[无锁化编程场景下的垃圾回收机制（一）](https://pwang7.github.io/eb.html)

引用计数：[并发编程（19）——引用计数型无锁栈](https://zhuanlan.zhihu.com/p/14465735868)

## 垃圾回收实现

[crossbeam](https://docs.rs/crossbeam/latest/crossbeam/index.html)实现了基于epoch的垃圾回收。[讲解文档](https://rustcc.cn/article?id=9562a416-3fdc-40a1-bf02-b4375b9a665a)

[arc_swap](https://docs.rs/arc-swap/latest/arc_swap/)实现了可进行原子操作的`Arc`对象。
