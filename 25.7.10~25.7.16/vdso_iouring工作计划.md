# vdso_iouring工作计划

使用vdso实现io_uring方式的队列，并在此基础上实现异步系统调用和IPC。

队列设计如[此处](想法.md)所示

采用该队列设计的好处：队列为MPSC模式，内核态可以只从一个队列接收系统调用请求，因此最少只需要一个轮询线程/协程处理请求；如果每个进程使用不同的队列，则每个进程都需要在内核配备轮询线程。同时，该设计可以很好地推广到IPC的情况，每个用户态进程也只需一个接收队列、一个轮询线程/协程。

采用vdso的好处：让相关代码可在用户态和内核态执行，因此，

- 用于系统调用的机制可以方便地推广到IPC。
- 可以兼容宏内核或微内核系统（通过IPC实现系统调用）

## 计划与时间安排

### vdso共享库实现的io_uring（2周）

- 实现接收队列的入队出队操作，并封装为io_uring的操作：（发送方）提交请求、填写；（接收方）取出请求；
- 实现进程/内核注册和取消注册接收队列的功能（可能需要寻找所需的无锁数据结构，可以先考察zfl学长的BTreeMap是否可用）；
- 设计队列元素的结构（也就是通信数据结构），例如需要包含发送方字段和消息类型字段。
- 使用zfl学长的vdso共享调度器中，根据vdso代码自动生成外部api代码的机制。

#### 无锁队列

下文中提到的队列均使用[此处](https://github.com/AsyncModules/vsched/blob/main/utils/src/deque.rs)的无锁环形缓冲区实现，支持MPMC和双端的`push`、`pop`。

接收队列的设计如下：

首先，无法沿用[原有的设计](https://gitee.com/LC_rosy/weekly-progress/blob/master/25.6.26~25.7.1/iouring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3)，即在同一块环形缓冲区上使用`khead/ktail`、`sqe_head/sqe_tail`标识两个队列。因为当所有进程共享同一组队列时，某个用户进程完成`sqe`填写时，不能保证其它进程也完成了`sqe`的填写。因此，某个用户进程调用`submit`时，`sqe_head`和`sqe_tail`之间可能仍存在其它进程未填写完成的`sqe`，导致`submit`后内核读到未填写完成的数据。

因此，只保留了在用户和内核间共享的接收队列一个队列。用户需要提交请求时，调用队列的`push_slot`方法，使接收队列入队一个空槽位，并将指针返回给用户。用户使用该指针填写`sqe`。内核的行为则与原有设计一致，均为`pop_front`获取`sqe`。

需要为队列实现额外的接口 **`push_slot`** ：将一个空元素加入队列，并返回其可变引用，使调用者可以更改该元素。其可以实现为：在`push`的基础上，省略填写数据和将槽位设置为`READY`的过程，使被`push`的槽位状态保留为`WRITING`；当返回的可变引用被释放时，再将状态设置为`READY`。

#### 队列的注册与取消注册

不同进程的接收队列以数组的形式存储，而数组的每一项包含以下内容：

- `state`字段，指示该项的状态，包括`EMPTY`、`PENDING`、`READY`。
- `id`字段，指示占用该项的进程的id。
- `using`字段，指示正在占用该队列的线程数量。初始为0。
- 无锁队列自身。

`state`、`id`、`using`均为原子字段。

**注册接收队列：** 先遍历数组找到一个`state`为`EMPTY`的数组项，通过CAS设置`state`为`PENDING`。再初始化无锁队列、设置`id`。最后，CAS设置`state`为`READY`。

**查找id对应的接收队列并执行操作：** 先遍历数组，找到`state`为`READY`、`id`为接收者id的队列。然后将`using += 1`，再次验证`state`为`READY`、`id`为接收者id。再在队列上进行操作。最后将`using -= 1`。（可以在本地内存维护一个`BTreeMap`作为缓存以减少遍历，每次根据其查找到对应位置后需要验证。）

**取消注册接收队列：** 先找到对应进程的队列，通过CAS设置`state`为`PENDING`。再等待`using`降到0。最后，通过CAS设置`state`为`EMPTY`。

#### 接口

接收队列的接口：

- **`get_sqe(receiver_id: usize) -> Result<SQERef>`** ：从共享数据的接收队列中获取一个`SQE`供用户填写。填写完成、释放引用后自动视为提交，不需要额外的提交操作。
- **`pop() -> Result<SQE>`** ：从共享数据的接收队列中取出一个`SQE`。
- **`pop_multiple(max: isize) -> Result<[SQE]>`** ：从共享数据的接收队列中取出多个`SQE`，`max == -1`代表全部取出。

进程注册/取消注册接收队列的接口：

- **`register(process_id: usize) -> Result`**：注册接收队列，同时模块也会保存该进程的id。
- **`unregister() -> Result`**：取消注册接收队列

#### 工作计划

- 第1周：基于zfl的vdso共享调度器，创建一个用于开发vdso共享库的模板，并使其正常运行
- 第2周：基于该模板开发vdso共享库，实现上述设计中的功能

### vdso共享库实现的异步系统调用模块（3周）

- 实现以下操作：
  - 向某个进程（或者内核）发送消息
  - 让自身的线程/协程等待特定消息到来
- 为每个进程/内核创建一个轮询线程/协程，从其接收队列中取出消息，唤醒对应的线程/协程并将消息返回给它。
- 需要有管理任务的阻塞/唤醒的方式。
- 需要考虑一些轮询线程的行为问题，例如接收到消息后，若没有正在等待的线程/协程，应该将消息取出并暂存在私有内存，从而不影响其它消息的读取。

采用修改后的队列结构，发送方和接收方是对称的，因此不必区分发送方和接收方。

使用该机制实现异步系统调用，则：

- 调用方（用户）线程/协程先向内核发送消息，再使自身等待内核返回的消息。
- 被调用方（内核）的每个系统调用处理函数均实现为等待对应消息的线程/协程，它们被唤醒后，先将自身重新注册为等待消息，再处理系统调用，最后将结果通过消息发送回调用方。
