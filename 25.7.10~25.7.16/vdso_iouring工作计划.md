# vdso_iouring工作计划

使用vdso实现io_uring方式的队列，并在此基础上实现异步系统调用和IPC。

采用共享队列的好处：内核态可以只从一个队列接收系统调用请求，因此最少只需要一个轮询线程/协程处理请求；如果每个进程使用不同的队列，则每个进程都需要在内核配备轮询线程。然而，共享队列也有不足：增加了并发冲突。

采用vdso的好处：让相关代码可在用户态和内核态执行，因此，

- 用于系统调用的机制可以方便地推广到IPC。
- 可以兼容宏内核或微内核系统（通过IPC实现系统调用）

## 计划与时间安排

### vdso共享库实现的io_uring（2周）

- 原本用mmap实现的提交队列（SQ）、完成队列（CQ）、实例数组（SQEs），可以实现为vdso共享库的共享数据。这会导致所有进程共享同一个上下文，队列从SPSC变为MPMC。
- 两个队列的入队出队操作
- 将入队出队操作封装为io_uring的操作：（用户态）提交请求、获取结果；（内核态）取出请求、放入结果；

#### 数据结构

下文中提到的队列均使用[此处](https://github.com/AsyncModules/vsched/blob/main/utils/src/deque.rs)的无锁环形缓冲区实现，支持MPMC和双端的`push`、`pop`。

`sq`的设计如下：

首先，无法沿用[原有的设计](https://gitee.com/LC_rosy/weekly-progress/blob/master/25.6.26~25.7.1/iouring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3)，即在同一块环形缓冲区上使用`khead/ktail`、`sqe_head/sqe_tail`标识两个队列。因为当所有进程共享同一组队列时，某个用户进程完成`sqe`填写时，不能保证其它进程也完成了`sqe`的填写。因此，某个用户进程调用`submit`时，`sqe_head`和`sqe_tail`之间可能仍存在其它进程未填写完成的`sqe`，导致`submit`后内核读到未填写完成的数据。

因此，只保留了在用户和内核间共享的`sq`一个队列。用户需要提交请求时，调用队列的`push_slot`方法，使`sq`队列入队一个空槽位，并将指针返回给用户。用户使用该指针填写`sqe`。内核的行为则与原有设计一致，均为`pop_front`获取`sqe`。

需要为队列实现额外的接口 **`push_slot`** ：将一个空元素加入队列，并返回其可变引用，使调用者可以更改该元素。其可以实现为：在`push`的基础上，省略填写数据和将槽位设置为`READY`的过程，使被`push`的槽位状态保留为`WRITING`；当返回的可变引用被释放时，再将状态设置为`READY`。

`cq`的设计与`sq`类似。

#### 接口

`sq`的接口：

- **`SQ::get_sqe() -> SQERef`** ：从共享数据的`SQ`中获取一个`SQE`供用户填写。填写完成、释放引用后自动视为提交，不需要额外的提交操作。
- **`SQ::pop() -> SQE`** ：从共享数据的`SQ`中取出一个`SQE`。
- **`SQ::pop_multiple(max: isize) -> [SQE]`** :从共享数据的`SQ`中取出多个`SQE`。

`cq`的接口与`sq`类似。

### vdso共享库实现的异步系统调用模块（3周）

调用方侧：发起系统调用后，将请求封装为`sqe`放入`sq`，之后阻塞调用者（如果调用者为协程，则可以直接返回`Pending`并保存`Context`；若为线程，则需要调用相关阻塞接口）。使用一个轮询协程轮询`cq`，在得到`cqe`后唤醒相关的调用方。

被调用方侧：通过轮询线程/协程轮询`sq`，从中取出请求并处理。

需要有管理任务的阻塞/唤醒的方式。
