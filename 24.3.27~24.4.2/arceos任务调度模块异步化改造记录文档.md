# arceos任务调度模块异步化改造记录文档

时间：2024/3/27

## 方案

因为一些应用的运行需要线程支持，因此计划同时支持线程调度和协程调度。因为ArceOS只有单个进程，因此不需支持进程调度。

原本认为，线程和协程作为实现方式不同的程序运行流的基本单位，具有相似性，因此计划将线程和协程作为同级的单位，使用硬件调度器同时调度和执行两者。在实现过程中发现，线程和协程的实现方式不同使得两者不太适合同级调度（例如，线程自带上下文，而协程不自带，执行过程中需要一个上下文；线程切换是上下文的切换，而协程切换时普通的函数调用，等等），但由于已经在同级调度的方向上进行了一些实现工作，因此继续按同级调度的方向进行下去了。

在将线程与协程统一进行调度的实现方案上，先后有过两版方案：

1. 将原有的“上下文切换”函数分割成“上下文保存”和“上下文恢复”两个函数，分别为线程和协程实现以上的两个函数。但这一方案由于函数调用带来的返回地址改变，使得线程保存/恢复上下文的汇编代码难以实现。同时，zfl学长认为这样的方案中，线程的切换和协程的切换比较割裂。因此该方案最后被放弃了。
2. 为线程实现`Future` trait，将其与协程一起放在`Executor`中调度。在线程的`Future`实现中写上下文保存和恢复的代码。该方案基本可以直接沿用原有的“上下文切换”函数，不会带来汇编实现上的困难。但由于`Executor`本身也需要一个上下文来运行，该方案中的线程切换会经历两次上下文切换（旧线程->Executor->新线程），带来了额外的开销。不过zfl学长认为这样的开销是可以接受的，因此选用了此方案来实现。

## 实现的简要描述

在原有的线程TCB`TaskInner`之外，实现协程的`AsyncTaskInner`。实现一个`AbsTaskInner` trait作为这两种struct的统一接口（其中包括了类似`Future`的接口）。使用`AxTask` struct包装这个trait object，以`AxTask`及其指针作为调度单位。

为每个CPU核心建立一个Executor，其会不断调用`atsintc`驱动，从硬件调度器中获取任务并执行。让每个CPU核心的启动代码最后都是对相应的Executor调用`run`方法，从而开始执行。

修改对应的api、外围机制（如等待队列）、ArceOS启动代码等以适应这一改变，同时将创建协程的api暴露给用户。

## 实现过程中遇到的问题

### trait object与胖指针

实现过程中，原本是想直接将`dyn AbsTaskInner`的指针作为调度单位的，但过程中发现了Rust语言的“胖指针”机制：指向trait object（或者slice）的指针，其指针的大小为两个usize而非一个usize。因此，在其外面包装了一层`AxTask`，将调度对象由trait object改为正常对象。

### Arc<T>与裸指针的转化问题

原本我将`Arc<T>`转化为裸指针，都是先获取引用，在将引用强转为裸指针。该行为最后引发了难以定位的运行时错误，导致我花了很长时间调试与修改，才发现问题的原因。正确的做法是，使用`Arc`提供的`Arc::into_raw()`和`Arc::from_raw()`函数来进行转化。

### Arc<T>的释放问题

使用`Arc<T>`时，需要注意它的自动释放，留意引用计数是否会降到0而导致`T·`提前释放。将Arc<T>转化为裸指针可以避免它在作用域结束时自动释放。