# FastWake论文阅读笔记

时间：2024/3/28

原文：[https://dl.acm.org/doi/abs/10.1145/3600061.3600063](https://dl.acm.org/doi/abs/10.1145/3600061.3600063)

## 摘要

中断和轮询模式的对比：中断模式允许在线程间共享处理器，但中断模式比轮询模式开销更大。（疑问：如果建立一个轮询线程，负责轮询网卡、接收结果、唤醒阻塞的任务，不是也能在线程间共享处理器吗？）

FastWake，对中断模式的RDMA网络栈的重新设计。（RDMA模式的网络栈和正常的TCP/IP不同）

方法1：完全移除中断，使用与核心一一对应的调度器线程，轮询同一核心上所有线程的任务队列，然后使用kernel fast path上下文切换到“completion event已经到来”的线程。拥有基本等同于轮询模式的性能，但它会使CPU时刻以100%利用率运行，因此有更节能的方法2。

方法2：因为使用中断唤醒相同核上的线程，比唤醒不同核上的线程更快，因此调整了RDMA事件队列映射，提高中断的核亲和性。之后，还修改了线程唤醒的内核路径，移除了tasklet、获取锁、进程切换的开销。

## 简介

一些应用场景，为了在多个线程间共享处理器时间，需要使用中断模式，但中断模式开销（6~10us）大于轮询模式（1.6us）。（“the killer microseconds”）

这个开销在TCP/IP协议栈中不受关注，因为协议栈本身的开销更大（>20us）。但在低延迟的RDMA中，就需要关注该开销了。

分享RDMA中断模式的开销，发现中断对核的亲和性很重要（相同核4us，不同核7~10us）。但即使在相同核上触发中断，开销仍然较大。

两种方案，一种完全移除中断，但提高了耗能；另一种降低中断时延，且对耗能的提高不明显。见摘要。

该方案兼容已有的RDMA应用。此外，该方案还提供了一种新的IPC机制。

## 背景

由于数据中心采用了RPC（远程过程调用），大大增加了一次轮询的开销，因此使用忙轮询直到任务完成的方式会显著浪费CPU资源。

解决时延问题：编程语言层面、操作系统层面、硬件架构层面。编程语言层面：协程，但它们存在限制了使用的编程语言、需要将系统的阻塞API重写成协程API等限制。操作系统层面：通过加速上下文切换、绕过调度器等方法减少IPC开销、利用硬件虚拟化，但它们聚焦于IPC，无法减少中断传递的时延（？）。硬件架构层面：新的硬件架构以单线程性能为代价加速上下文切换，但它们还未准备好部署。

之后都是对RDMA机制的介绍，感觉目前可以不看？