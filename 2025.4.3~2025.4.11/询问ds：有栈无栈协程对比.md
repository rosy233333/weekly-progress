目前，在主流编程语言或平台的协程实现中，**无栈协程（Stackless Coroutines）的普及程度更高**，但具体选择取决于语言设计目标和应用场景。以下是详细分析：

---

### **1. 无栈协程（Stackless）更常见的原因**
无栈协程是近年来许多现代语言的首选，主要因为：
- **轻量级**：无需为每个协程分配独立栈，内存占用更小，适合大规模并发（如数百万级并发任务）。
- **与异步编程深度整合**：天然适合 `async/await` 模型（如 JavaScript、Python、Rust、C#、Kotlin 等）。
- **编译器优化**：协程的挂起和恢复由编译器生成状态机代码，运行时开销低。
- **主流语言推动**：
  - **JavaScript/TypeScript**：通过 `Promise` 和 `async/await` 实现无栈协程。
  - **Python**：`asyncio` 库基于生成器（无栈协程）。
  - **Rust**：`async/await` 语法糖生成无栈协程。
  - **C#**：`async/await` 模型是无栈协程的典型实现。
  - **Kotlin**：协程通过挂起函数（suspending functions）实现无栈模型。
  - **C++20**：标准引入的无栈协程（需编译器支持）。

---

### **2. 有栈协程（Stackful）的典型场景**
有栈协程在需要**深度灵活控制**的场景中仍有优势：
- **任意嵌套挂起**：可在任意函数调用层级挂起（无需标记 `async`）。
- **与系统线程更接近**：适合需要“类线程”行为的场景（如复杂任务调度）。
- **代表语言/框架**：
  - **Go**：`goroutine` 是典型的有栈协程，每个协程拥有独立栈（初始 2KB，动态扩展）。
  - **Lua**：内置协程（`coroutine`）是有栈的。
  - **Java（Project Loom）**：虚拟线程（Virtual Threads）可视为有栈协程的扩展。
  - **Erlang/Elixir**：轻量级进程（类似有栈协程，独立栈和堆）。

---

### **3. 现状对比**
| **类别**       | **代表语言/平台**                          | **使用场景**                           |
|----------------|----------------------------------------|--------------------------------------|
| **无栈协程**   | JavaScript、Python、Rust、C#、Kotlin、C++ | 高并发 I/O 密集型任务（如网络服务、异步编程） |
| **有栈协程**   | Go、Lua、Java（Loom）、Erlang           | 需要灵活挂起或类线程行为的场景（如复杂并发逻辑） |

- **数量趋势**：无栈协程在语言实现中占比更高（尤其是新兴语言），因其更贴合现代异步编程需求。
- **性能取舍**：无栈协程更轻量，但有栈协程在调试和灵活性上更优。

---

### **总结**
- **无栈协程更多**：现代语言普遍采用无栈模型，尤其在异步编程领域占据主流。
- **有栈协程仍不可替代**：在需要深度控制或类线程行为的场景中（如 Go 的并发模型）仍广泛使用。

两者并非完全对立，例如 **Rust** 的无栈协程可通过生成器模拟有栈行为，而 **Java Loom** 的虚拟线程试图结合两者的优势。未来协程设计可能会进一步模糊二者的界限。