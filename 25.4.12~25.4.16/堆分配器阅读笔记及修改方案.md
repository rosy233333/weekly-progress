# 堆分配器阅读笔记及修改方案

时间：2025.4.12

## linked_list.rs

本节实现了侵入式链表，但还未能实现无锁同步。

**一次或多次读、一次写的函数：`LinkedList::push`、`LinkedList::pop`。** 这些函数不会造成链表的状态不一致，但在写之前没有验证读到数据的有效性。将写操作改为CAS，加上失败重试即可解决。

**`LinkedList::iter_mut`函数**：首先，注释中说prev的设置有问题，不过我检查后觉得似乎是没问题的。之后，该函数中虽然进行了两次对`self`的读取，但其中的`&mut self.head`在函数执行过程中是不变的，因此不涉及同步问题？

**`Iter`和`IterMut`**：因为迭代器不可共享，因此不用考虑迭代器自身字段的同步问题。只需考虑迭代器对节点的访问是否有同步问题。

**`Iter`和`IterMut`的数据有效性**：由于从迭代器中读出的数据可能在之后继续使用，因此需要考虑这些数据是否仍有效。对于`Iter`，因为`Iter::next`没有同步问题，且无法从读出的数据修改链表，因此直接认为读出的是迭代器迭代时的版本的数据即可。对于`IterMut`，虽然`IterMut::next`也没有同步问题，但其读出的数据可以用于在之后修改链表，因此需要验证读出数据的有效性（prev和curr是否依然在链表上）。

**`ListNode::pop`**：先读了本节点，再写了上一节点。需要考虑同步问题。

关于`IterMut`和`ListNode`的有效性问题和同步问题比较复杂，我目前还没考虑出确定的结果，例如，如果需要用`ListNode`修改链表，则需要这个`ListNode`有效，那如果发现了该节点无效，那这个修改操作是无法通过重试来完成的，只能返回失败的结果。但处理这种修改失败会很困难。因为它需要获取新的`IterMut`重新迭代一遍，才可能取到有效的数据。

## imp.rs

这个文件实现了使用buddy_system的堆分配器。其使用多个`LinkedList`记录不同大小的空闲区域，同时还具有`user`、`allocated`、`total`等统计信息。

对于统计信息的同步很简单，直接使用`AtomicUsize`即可。对于空闲区的同步，在假设链表已经实现了无锁同步的基础上，还需要关注多个读-写操作间的数据有效性。

**`Heap::add_to_heap`**：其只包含写操作，因此不涉及数据有效性问题。

**`Heap::alloc`**：该函数先判断对应大小的`LinkedList`是否有空虚块（读操作），如果没有，则从更大的`LinkedList`中切分。切分过程只涉及写操作，不涉及数据有效性问题。

不过，这个函数可能会产生未合并的空闲块。原因是，切分过程从更大的链表获取到空闲块并切分后，会先将两个块都push入较小的链表，再从链表中pop一个出来。如果在push和pop之间，对应的链表中插入了新的空闲块，则会把两个可合并的空闲块留在链表中。未合并的空闲块不会被`dealloc`的合并过程检测到，因为`dealloc`的合并过程只会检测新空闲块是否和某一个已有空闲块可合并。未合并的空闲块会导致性能问题。若要解决，则可以把两次push、一次pop改成一次push。

**`Heap::dealloc`**：该函数由于在插入空闲块时，采用了先插入再合并的策略，再加上需要频繁检查链表中是否有可合并的块，因此具有大量相关的读写操作，难以分析。我觉得，需要先将“先插入再合并”改为“先合并再插入”，减少写操作的数量，再进行同步分析。
