# 毕设项目debug记录

时间：2024/4/22

## 各个仓库的修改完成的commit

操作系统`arceos-ats-intc`：[https://github.com/rosy233333/arceos-ats-intc/commit/b44e2db4cdaf19778a3e922fa95dbfcb4028e252](https://github.com/rosy233333/arceos-ats-intc/commit/b44e2db4cdaf19778a3e922fa95dbfcb4028e252)

驱动`ats-intc`：[https://github.com/rosy233333/ats-intc/commit/d2742f6c9345ecb0983177b85f96bd928c7a0d84](https://github.com/rosy233333/ats-intc/commit/d2742f6c9345ecb0983177b85f96bd928c7a0d84)

模拟器`qemu`：[https://github.com/rosy233333/qemu/commit/1b7901c7a330fcbb5ff432888932387fe5ddb9d3](https://github.com/rosy233333/qemu/commit/1b7901c7a330fcbb5ff432888932387fe5ddb9d3)

## bug描述

在使用修改后的调度模块，在4核或以上核心数运行多任务（无论是多线程还是多协程）程序时，可能出现`Segmentation fault`。核心数越多、创建的任务数越多，出错概率越大。在创建16个线程的实验中，使用4核基本不会出错，5核可能出错，8核总是出错。

## 排查和修改过程

### 第一次修改

首先重点检查任务调度模块中的`unsafe`代码。发现其中很多`unsafe`代码都是用于将trait object引用转化为具体的对象的引用。（该部分以前是使用指针强行转化，因此使用了`unsafe`代码。）之后了解到，实现该功能存在安全方法：新增一个将trait object转化为每种子类对象的trait。之后，将它们修改为安全代码。然而错误还是出现。

### 第二次修改

由于是在多核情况下出错，考虑是同步问题。因此，为各个线程都需访问的静态数据结构（驱动对象`ATS_DRIVER`、调度器对象`ATS_EXECUTOR`、当前任务指针`CURRENT_TASK`）加锁。其中，`ATS_EXECUTOR`和`CURRENT_TASK`都是每个核心拥有各自的实例，但我之前将这些实例以`Vec`的方式存储在静态变量中，导致不同的核心对这些`Vec`同步访问。加锁后，问题依然出现，无明显改善。

之后进行了一系列测试：

1. 首先，将多核启动代码中，所有核最后都会进入`ATS_EXECUTOR.run()`任务运行方法改为只有一个/一部分核进入。结果为，只有主核心进入该方法时，不会出现错误。其它情况，包括只有一个或多个副核心，或者主核心和多个副核心进入`run`方法的情况，都会导致错误。这样，将bug的范围缩小到`ATS_EXECUTOR.run()`方法中。
2. 测试了不同的启动线程数量，发现，启动的线程越多，出错概率越高。但就算不额外启动线程，系统启动时创建的`main`线程也有很小概率引发错误。
3. 测试了不同的CPU核心数量，发现核心数量越多，出错概率越高。在创建16个线程的实验中，使用4核基本不会出错，5核可能出错，8核几乎总会出错。

仍然认为是同步访问的问题。在debug过程中，发现了ArceOS提供的`percpu`可以提供每个CPU一份的对象的创建和访问，因此将`ATS_EXECUTOR`和`CURRENT_TASK`两个对象改为使用`percpu`库实现。这样修改完成后，发现出错的概率减小但仍会出错。16线程、8核心的实验结果由“总是出错”变为“大概率出错，小概率正常运行”。因此认为，段错误bug由多种原因引起，这一修改解决了一部分原因。

### 第三次修改

之前的`percpu`库虽然解决了`ATS_EXECUTOR`和`CURRENT_TASK`的问题，但对于`ATS_DRIVER`，却无法解决。我尝试了两种方法：让多核加锁地访问同一个`ATS_DRIVER`，以及让每个核心访问自己的，`percpu`实现的`ATS_DRIVER`，但问题都存在，并且两者的出现概率相差不大。

不过现在也把问题缩小到了`ATS_DRIVER`对象上。通过注释掉`ATS_EXECUTOR.run()`中的不同代码再运行，发现导致问题的代码为`ATS_DRIVER.ps_fetch()`，也就是从调度器获取要运行的任务指针。为了分辨是代码运行过程中的错误，还是代码返回了错误的指针导致错误，我保留这行代码，但不使用它的返回值，运行仍会出错。证明是这行代码运行过程中的错误。

即使将问题定位到这行代码，想继续找出原因也较为困难，因为它表明问题可能位于调度器驱动（`ats-intc`仓库）上，或者位于模拟器（`qemu`仓库）上。

原本的调度器驱动采用`svd2rust`库提供了对硬件的访问。为了排查调度器驱动的原因，我又实现了两个版本的驱动：

1. 完全用软件模拟硬件调度器的行为，不调用硬件。
2. 直接计算地址访问硬件，不经过`svd2rust`库。

这些版本的驱动位于仓库分支[https://github.com/rosy233333/ats-intc/tree/simulation](https://github.com/rosy233333/ats-intc/tree/simulation)中。

使用这两个版本和原版本的驱动继续进行上述测试。

结果显示，软件实现的驱动完全不会出错。因此彻底排除了`ArceOS`系统的问题，确定问题原因在驱动或者硬件中。

而调用硬件的两种驱动有不同的实验结果：在“保留`ATS_DRIVER.ps_fetch()`代码，但不使用它的返回值”实验中，`svd2rust`实现会读取硬件，并造成错误；而直接实现连硬件也不会读取，造成了没有错误的现象。该现象误导了我一段时间，让我再次以为是返回值出错，直到我发现输出中没有读取硬件的信息。之后我以为直接实现本身有问题，检查了其中的地址计算，并未发现问题。最后发现，是由于这句代码的结果未被使用，因此直接被编译器优化删除了。在其中添加打印代码，解决了该问题，之后直接实现得出了和`svd2rust`实现相同的结果。

### 第四次修改

根据以上结果，最终确定了问题在硬件调度器中。在硬件调度器的访问队列的操作上加锁，问题依旧出现。

又由于之前确定导致问题的是`ATS_DRIVER.ps_fetch()`代码，因此重点关注硬件调度器代码中取出就绪任务的部分。最后确定，问题在从队列中弹出元素的实现上。原本的实现先释放了元素的空间，再将元素从队列上移除，导致其它核可能访问到被释放的空间。改变两句代码的位置，再进行测试，问题成功解决。

然而，由于加锁，导致测试时，发现调度性能明显下降。之后测试发现，在调度器中已经加锁的情况下，ArceOS系统中不需加锁，也不会出现问题。这样修改后，稍微提升了性能。