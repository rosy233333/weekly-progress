# 项目描述文档

时间：2024/6/30

## 项目描述

编写不与特定操作系统绑定、适用于多种基于 Rust 语言的操作系统（下文称为 Rust 操作系统）的任务调度模块。它可以直接作为 Rust 操作系统的组件，从而方便 Rust 操作系统的开发。

## 功能目标

基础功能：

- [ ] 向操作系统提供描述任务的接口和使用调度器的接口
- [ ] 队列管理功能（就绪队列、阻塞队列）
- [ ] 任务运行功能

需优先实现/提早考虑的扩展功能：

- [ ] 支持hypervisor、操作系统、进程、线程、协程的多级调度
- [ ] 与[学长的工作](https://github.com/ATS-INTC/moic)结合，支持学长的硬件调度器

一般扩展功能：

- [ ] 提供任务调度算法的接口，支持多种任务调度算法
- [ ] 支持多核
- [ ] 支持优先级调度

## 比赛目标和计划

目标：

- [ ] 开发满足功能目标的调度框架
- [ ] 将arceos、alien、rcore的任务调度模块改为使用该框架实现，证明该框架的可移植性。

计划：

- 7.2 ~ 7.8     实现基础功能和优先考虑的扩展功能
- 7.9 ~ 7.15    实现其它扩展功能
- 7.16 ~ 7.21   移植到已有的Rust操作系统中
- 7.22 ~ 7.28   继续移植；准备总结文档和演示视频 

## 项目设计

### `feature`

采用 Rust 语言的 `feature` 功能，实现对一些调度功能的选择性支持。

由于这些功能可能会降低任务调度模块的通用性（例如，外部中断处理功能可能会和具体的硬件架构绑定），因此将它们作为 `feature` 实现。

计划实现这些feature：

- `ext_intr`：外部中断处理功能
- `ipc`：进程间通信功能
- `moic`：使用zfl学长设计的硬件 `MOIC` 实现任务调度、中断处理和IPC
- `priority`：支持任务优先级

不同的 `feature` 可以各自独立启用或任意组合启用。这说明，对于外部中断和IPC功能，本项目需要实现软件方案，同时兼容zfl学长的硬件方案。

### `Runtime`

#### 介绍

管理 `Scheduler` 和 `BlockQueue` 等调度器部件的数据结构，为它们提供相同的作用域。

各个`Scheduler` 和 `BlockQueue` 对象都存储在 `Runtime` 中，而向用户提供它们的 `Arc` 指针。

#### 方法

`fn new_scheduler(&mut self) -> Arc<Scheduler>`

`fn new_blockqueue(&mut self) -> Arc<BlockQueue>`

( feature `ext_intr` ) `fn new_ext_intr_controller(&mut self) -> Arc<ExtIntrController>`

( feature `ipc` ) `fn new_ipc_controller(&mut self) -> Arc<IpcController>`

（对于这些数据结构如何释放，暂时没有明确的设计）

### `Scheduler`

#### 介绍

调度器负责管理就绪和运行的任务，并且从中取出任务运行。

如果启用了 `moic` feature ，则可以利用 `MOIC` 硬件进行调度。

#### 方法

`run(&mut self) -> !`

运行调度器，使其不断取出就绪队列中的任务并运行。

`add(&mut self, task: Task)`

向调度器中加入任务。

`current_task(&self) -> &Task`

获取调度器当前正在运行的任务。

该接口还未完全确定，主要是不确定获取的任务是什么形式，而且不知道会不会破坏“每个任务在内存中同时有且只有一个实例”的条件。

`ready_tasks(&self) -> &[&Task]`

获取调度器中就绪的所有任务。

该接口还未完全确定，主要是不确定获取的任务是什么形式，而且不知道会不会破坏“每个任务在内存中同时有且只有一个实例”的条件。

### `BlockQueue`

#### 介绍

阻塞队列用于存放因相同原因阻塞的一系列任务，并唤醒它们。

#### 方法

`add(&mut self, task: Task)`

向阻塞队列中加入任务。

`wake_one(&mut self)`

唤醒阻塞队列中的一个任务。

该接口还未完全确定，因为尚不清楚调度器和阻塞队列的关系，不知道阻塞队列如何将任务放入调度器中。

`wake_all(&mut self)`

唤醒阻塞队列中的所有任务。

该接口还未完全确定，因为尚不清楚调度器和阻塞队列的关系，不知道阻塞队列如何将任务放入调度器中。

`block_tasks(&self) -> &[&Task]`

获取阻塞队列中的所有任务。

该接口还未完全确定，主要是不确定获取的任务是什么形式，而且不知道会不会破坏“每个任务在内存中同时有且只有一个实例”的条件。

### `Task`

#### 介绍

该数据结构代表任务，且可以代表不同种类的任务（如hypervisor、os、进程、线程、协程）。尚不清楚如何实现这种多态，是使用泛型？还是trait object？

为了实现不同种类任务间的包含关系，我们将任务分为两种：调度器任务和单执行流任务。单执行流任务（例如线程、协程）只有一条执行流，它在运行时只会执行自己的执行流。调度器任务（例如hypervisor、os、进程）内部包含一个调度器和其中的多个任务，它在运行时会使用调度器运行内部的每个任务。它们对外的接口相同，都可以放入调度器中。因此，调度器任务内部的调度器也可以包含另一个调度器任务，实现任务的多级嵌套，从而满足类似“OS内核调度用户进程，用户进程调度用户线程和用户协程”的场景。

#### 方法

`fn run(&self) -> ReturnAction`

运行该任务，直至它主动或被动让出CPU。 `ReturnAction` 枚举说明了该任务返回后的状态，以及依据该状态，应该对它进行何种处理。例如，是放回就绪队列、放入某个阻塞队列，还是释放掉？

```Rust
enum ReturnAction {
    Ready(Arc<Scheduler>), // 将返回后的任务放入 Scheduler 中，等待下一次调度
    Block(Arc<BlockQueue>), // 将返回后的任务放入 BlockQueue 中，阻塞
    Drop, // 将返回后的任务释放
}
```

`fn from_scheduler(scheduler: Arc<Scheduler>) -> Task`

根据传入的调度器，创建一个调度器任务。

`fn from_trait<T: SomeTrait>(task: T) -> Task`

根据一个满足某些特征的数据结构创建任务。目前尚不清楚该特征要如何定义。该方法使得一些操作系统已经定义好的任务数据结构可以转化为该框架中的任务。

`fn from_fnonce(task: 满足某些条件的FnOnce) -> Task`

`fn from_future(task: 满足某些条件的Future) -> Task`

这两个方法提供了直接创建任务的结构，可以直接创建线程或协程。

### ( feature `ext_intr` ) `ExtIntrController`

#### 介绍

该数据结构用于处理外部中断。在未启用 `moic` feature 时，其内部由 `BlockQueue` 实现，可以阻塞和唤醒任务。

在启用 `moic` feature 时，其调用 `moic_driver` 库，由 `MOIC` 硬件实现。

#### 方法

`fn register_handler(&mut self, handler: Task, irq_num: usize)`

注册中断处理任务。对应中断号的中断到来时，从中取出该任务并运行（目前尚不清楚应该加入哪个Scheduler）。

`fn handle(&mut self, irq_num: usize)`

当中断到来时，调用该函数，以触发中断处理过程。因此，该函数需要注册到OS的中断处理函数中。

### ( feature `ipc` ) `IpcController`

#### 介绍

该数据结构用于处理进程间通信。其可以注册发方和收方，并发出IPC。

在未启用 `moic` feature 时，其内部由 `BlockQueue` 实现。

在启用 `moic` feature 时，其调用 `moic_driver` 库，由 `MOIC` 硬件实现。

#### 方法

`fn register_sender(参数未确定)`

`fn register_receiver(参数未确定)`

`fn send(参数未确定)`

这些函数分别用于注册发方、注册收方、发送中断。

还未确定参数的原因，是尚未弄清楚学长的设计中的“指定OS、指定线程、指定任务”如何在我的框架中体现，并且学长的多级任务调度结构更为固定，而本系统中的结构相对自由，不知要如何整合。