#

``` Mermaid
flowchart TD
hv([hypervisor]) --> os([操作系统内核]) --> p([用户进程])
p --> 用户线程
p --> 用户协程
os --> 系统线程
os --> 系统协程
```

## 协程的上下文保存与恢复

- 需要保存哪些上下文？只需保存指向Future的指针就行。
- 是否需要换栈？如果在相同的地址空间内，从协程切到协程，那就不需换栈。否则需要。
- 协程在什么执行环境里执行？
  - 按照目前的设计，是换到新栈之后，运行调度器取出任务。因此，调度器能够在空栈中执行。而协程也最好在空栈中执行（为了栈的复用）。
- 需要与线程的执行流具有相似性，使其被强制切换时可以直接沿用线程的切换机制。还需要在主动切换时，切换开销更小。

## 线程与协程的执行流

### 线程的执行流（思路2/传统情况）

- 启动后，首先在空栈上执行线程最外层代码。
- 因为内部或外部因素，产生了中断/异常/陷入。因此，将线程当前的执行流保存为trap上下文，陷入内核态，在一条新的内核态执行流中进行中断/异常/陷入的处理。
  - 原线程的执行流和内核态执行流虽然是两条不同的执行流，但它们有明确的执行顺序和逻辑上的“调用-返回”关系，因此属于同步而非异步。
- 内核态执行流可能直接返回原执行流，也可能切换到其它任务再返回（例如，对于需要将切换原线程的情形）。
- 若内核态执行流切换到其它任务，则它会调用位于跳板的切换函数。 *（此处假定已经将所有的任务切换放在跳板上进行）* 在内核态执行流的视角中，该函数正常返回。但实际上，其会在切换函数中切换到其它任务，并在再次切换回时恢复执行。切换时，因为栈可能非空，因此需要换栈。

### 线程的执行流（思路1/系统中的情况）

- 启动后，首先在空栈上执行线程最外层代码。
- 产生中断/异常/陷入后，也需要切换到内核执行流，并等待该执行流返回的结果。

## 任务调度的各种场景（目前仅考虑OS及以下层次的情况）

1. 内核态 -> 内核态：
   1. 强制切换（一定为线程）：
      1. 内核线程时间片耗尽、时钟中断导致的切换：可以直接切换到下一个内核线程，也可以先切换到中断处理函数处理，再切换到下一个内核线程？
      2. 其它中断/异常：直接切换到中断处理函数。
   2. 主动切换：
      1. 主动让权，切换到内核线程/协程：
         1. 线程：见2.2.1.1.。
         2. 协程：待定。
      2. 从中断处理函数返回被中断的内核线程：进入跳板页，进行一次切换。
2. 用户态 -> 用户态：
   1. 强制切换（一定为线程）：
      1. 线程时间片耗尽、时钟中断导致的切换：
         1. 不使用用户态中断：时钟中断必须在内核处理。因此需要在收到中断时先切换到线程对应的内核执行流，在中断处理函数中调用跳板函数进行切换，再从切换到的新的内核执行流返回新的用户线程。需要进行三次切换。**即使使用了2.1.1.2.中的“由中断跳转到跳板页”的方法，仍需进行三次切换？并且该方法还有一个问题：线程切换的实际步骤（从原线程的内核执行流到新线程的内核执行流）在内核中进行，而内核调度器没有关于用户进程内线程的信息。**
         2. 使用用户态中断：**可以直接修改中断处理过程，使其以类似函数调用的方式跳转到跳板页？再在跳板页中直接切到另一个线程。**
      2. 进程时间片耗尽、时钟中断导致的切换到另一个用户进程中的线程：见2.1.1.1.。**此处用户态中断无法发挥作用？因为进程间的切换必须使用内核调度器，进程自身的调度器没有足够的信息。**
      3. 在使用用户态中断的情况下，在用户态处理其它类型的中断：见1.1.2.。
   2. 主动切换：
      1. 切换到相同地址空间的线程/协程：
         1. 线程：可以直接在让权函数中调用跳板函数，只需进行一次切换。
         2. 协程：待定
      2. 切换到不同地址空间的线程/协程：
         1. 线程：可以直接在让权函数中调用跳板函数切换到内核执行流，再从内核执行流切换到另一进程的内核执行流。**不确定……一个进程的内核执行流是唯一的吗？这个情况很复杂，比如说，本进程的一个线程让权给其它进程了，那该进程的其它线程需要被强制切换吗？**
         2. 协程：待定
3. 用户态 -> 内核态：
   1. 强制切换（一定为线程）：
      1. 进程时间片耗尽、时钟中断导致的切换：见2.1.2.。只是此处，新的内核执行流不需返回用户线程，因此只需要两次切换。
      2. 线程出现其它中断/异常：此时只需要切换到线程对应的内核执行流，只需进行一次切换。
   2. 主动切换：
      1. 线程发起系统调用：见3.1.2.。
      2. 主动让权：
         1. 线程：可以直接在让权函数中调用跳板函数，只需进行一次切换。**可以使用原有的中断机制切换，也可使用2.1.1.2.中的“由中断跳转到跳板页”的方法，将这种切换也交由跳板页管理？同样具有2.2.2.1.中的疑问。**
         2. 协程：待定
4. 内核态 -> 用户态：
   1. 内核线程时间片耗尽、时钟中断导致的切换到用户进程：见1.1.1.，只是切换目标变为用户进程，因此切到进程对应的内核执行流后需要再返回用户态。进行两次切换。
   2. 主动切换：
      1. 主动让权，切换到用户进程：
         1. 线程：可以直接在让权函数中调用跳板函数，切到进程对应的内核态执行流后再返回用户态。进行两次切换。
         2. 协程：待定
      2. 从中断处理函数返回被中断的用户线程：见1.2.2.。

## 单次切换中，影响跳板页行为的因素

1. 原任务相关信息，在触发切换时获得：
   1. 触发切换的方式：正常调度；中断处理；中断返回 
   2. 原任务类型：进程（？）、线程、协程 *（此处不确定是否包含进程，因为：一方面，被切换的单位应该是执行流，因此不包含进程；另一方面，内核调度器的元素中包含用户进程，因此也可以以进程为单位发起切换？）*
   3. 原任务的特权级、原任务的地址空间token
2. 目标任务相关信息，在取得目标任务时获得：
   1. 目标任务上次触发切换的方式：新建；正常调度；中断处理
   2. 目标任务类型
   3. 目标任务特权级、地址空间token

“触发切换的方式”对跳板页的切换行为的影响：

1. 影响保存和恢复的上下文：使用“正常调度”进行线程切换时，只需保存callee-saved寄存器；使用“中断处理”进行线程切换时，需要保存所有通用寄存器以及一些CSR。
2. 影响获取目标任务的方式：正常调度->通过调度器获取；中断处理->一条新建的中断处理执行流；中断返回->中断处理执行流的“调用者”作为目标任务
3. 影响一部分切换行为：特权级的切换和地址空间的切换只会在“中断处理”和“中断返回”类型的切换里出现。但“中断处理”和“中断返回”类型的切换不一定涉及地址空间的切换。
4. 比较原任务和目标任务的切换方式，可以起到验证有效性的作用：“正常调度”时，目标任务只能为“新建”或“正常调度”；“中断处理”时，目标任务只能为“新建”；“中断返回”时，目标任务只能为“中断处理”。

目前的想法是，将“触发切换的方式”也保存在TaskContext数据结构中。初始化时，其值为“新建”。之后任务每次切换都会更新该值为“正常调度”、“中断处理”或“中断返回”。