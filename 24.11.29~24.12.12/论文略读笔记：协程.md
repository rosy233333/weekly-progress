# 论文略读笔记

时间：2024/12/9

## 阅读的文章

[Revisiting coroutines](https://dl.acm.org/doi/10.1145/1462166.1462167)

[Kotlin coroutines: design and implementation](https://dl.acm.org/doi/10.1145/3486607.3486751)

## 特点

虽然对协程没有明确的定义，但其公认的特点为：协程在返回时保存自身的状态，并在下一次调用时恢复到该状态继续执行。或者说，协程采用**协作式调度**。而作为对比，线程采用抢占式调度。前者的任务让出时机由应用开发者决定，后者由操作系统或运行时决定。

因此，判断一种任务实现是否是协程，首要的依据是其是否采用协作式调度。而任务的其它特点，例如上下文是否有栈、是否采用async-await语法，与其是否为协程没有严格的对应关系。（不过，如果限定了范围，则后两者有时也可作为判断依据，例如Rust语言中的协程就是采用async-await语法的无栈协程。）

## 发展过程

1. 最早在1963年正式提出，用于实现多个编译步骤在同一代码段上交替执行的编译器。
2. 1980年之后，线程取代协程成为主要的多任务实现方式。原因为，当时协程的对称式控制流切换方式不符合结构化程序设计理念，且线程的抢占式调度使用户程序编写者不需要考虑任务让出问题，降低开发难度。
3. 2010年之后，在高并发I/O编程中，原有的回调函数语法具有可读性和复杂性上的不足。async-await语法为解决这一问题而提出，并使协程重新受到关注。在这之后，许多语言/程序库都采用协程提供高并发I/O的支持。

## 几组对比

在协程的不同发展阶段，根据协程使用范围的不同，也会将协程与不同的对象进行对比。

### 协程vs.函数

将协程与函数对比，是因为协程一般被实现为一种支持调用和返回的计算机例程，与函数类似。但它们具有两个不同点：

1. 实现上：协程具有（可在多次调用间保存的）内部状态，而函数一般没有。而那些具有内部状态的函数（如迭代器等）也可被认为具有一定的协程特征。
2. 语义上：函数的调用代表发起一个任务，而返回代表任务完成。而协程的调用可能代表发起任务或继续（未完成的）任务，协程的返回可能代表暂停或完成。

### 协程vs.线程

将协程与线程对比，是因为两者都可以用于实现多任务处理。它们的区别如下：

1. （首要区别）调度方式上：协程采用协作式调度，线程采用抢占式调度。因此，编写协程时，需要编写者手动管理任务的让出时机，而编写线程时则基本不需要。
2. 性能上：一般来说，做出协程性能高于线程的论断的原因之一是当前线程基本在内核态实现，而协程基本在用户态实现。但在仅有调度方式不同，其它条件（包括所处特权级）均相同的前提下：有栈协程的上下文切换开销与线程类似，而无栈协程可以具有低于线程的切换开销。

### 协程vs.回调

将协程与回调函数对比，是因为现在协程常用于处理高并发I/O，应用范围与回调函数类似。

1. 语法上：回调函数会导致实现同一逻辑的代码分散到不同函数中，降低可读性，增大复杂度。而协程可以解决这个问题，并且相比回调函数，其语法更接近于线程。
2. 实现上：一部分协程内部采用类似回调函数的机制实现，在此基础上提供对开发者更为友好的接口。

## 协程的优势与挑战

### 优势

1. 性能：协程采取的协作式调度方式，使得在语言和编译器层面提供合适的支持后，可以取得（相比线程）更低的任务切换开销。
2. 高并发I/O：协程的低开销使得创建大量协程分别处理I/O任务成为可能，而其协作式调度适用于I/O任务等待设备或操作系统的处理而让出的场景。

### 挑战

1. 编码：协程需要开发者主动管理任务的让出时机，因此其开发难度高于线程。不过，使用async-await语法配合支持协程的I/O库函数可以一定程度上解决该问题。
2. 代码兼容问题：使用async-await语法的协程会带来同步代码与异步代码的兼容问题：同步代码只能调用同步代码，异步代码可以调用同步或异步代码。这导致很多情况下需要对同步代码和异步代码实现两套函数。
3. 与面向对象模式的结合：在使用async-await语法的情况下，对象的构造函数、析构函数能否是异步函数？接口函数能否是异步函数？
