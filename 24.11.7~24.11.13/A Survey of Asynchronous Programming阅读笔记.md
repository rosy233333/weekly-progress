# A Survey of Asynchronous Programming Using Coroutines in the Internet of Things and Embedded Systems阅读笔记

时间：2024.11.11

## 摘要

研究资源受限平台上的协程，考虑分析其软件平台、硬件平台、容量？（capacity）、用例、意图的优点、应用程序编程接口。

采用了[系统映射研究（systematic mapping study）](https://www.zhihu.com/question/352901498)的研究方式，在2007~2018年间研究该问题的566篇文献中筛选出了35篇。

- 使用C/C++语言：22篇
- 8或16位处理器：16篇；32位处理器：13篇
- 四个最常见的用例：并发（17篇）、网络通信（15篇）、传感器读数（9篇）、数据流（7篇）
- 最常见的意图优点：代码风格和简洁（12篇）、调度（9篇）和效率（8篇）

结论：资源受限设备对C++中的协程有广泛的需求。

## 介绍

很多物联网和嵌入式系统使用事件驱动架构。事件驱动代码的“阶段分离”特性，即将请求之前的代码和响应之后的代码分离到了不同的位置，导致了编程的困难。

协程和Promise是对阶段分离问题的解决方案之一。在文章撰写时，C或C++还没有稳定的协程支持。（现在C++是有协程的）

原本对C++协程的研究很少考虑资源受限平台。

## 背景

### async/await模式

C++20中，使用`co_await`、`co_yield`、`co_return`关键字。

### 协程

协程通过增添挂起和继续操作，扩展了函数的概念。

协程可被用于事件处理、数据流、协作式多任务，以及async/await模式。

协程会在挂起时保存当前执行位置，以及有时（但不是总是）保存局部变量。

协程的分类：

- 保存内部状态的方式：作为局部变量保存进上下文/使用全局或静态变量，不需保存。
- 有栈/无栈（在C++ N4680提议的无栈协程中，所有的yield或return操作都必须在协程内部，不能在协程的子过程中）

### 过去面向资源受限平台的协程实现

#### Protothread

较早的实现使用C的宏。在`switch-case`语句的`case`中不使用`break`来实现协程（称为Protothread）：

```C
// 这些switch语句会用宏封装，因此用户无法直观了解到switch语句的使用
static int state = 0;
switch(state) {
case 0:
    // 协程代码
    state = 1;
    if(need_suspend) { break; }
case 1:
    // ...
// ...
case LAST_STATE: 
    // ...
    state = 0;
}
```

它具有特别轻量（编码时间、内存占用、速度上均表现特别出色）、可移植性高（因为使用纯C语言实现）

但它也具有以下缺点：

- 它违反了C语言的编码标准，导致无法在协程中使用switch语句。
- 它不会帮助程序员管理局部变量；需要跨让出点保存的变量需要手动声明为静态变量，这也使协程丧失了可重入性。

#### 其它实现

Engelschall 2000：总结了使用`setjmp`、`longjmp`的协程实现

Rossetto and Rodriguez 2006：以协程（有栈、保存局部变量）为基础的并发模型，作为TinyOS的扩展。

Andersen et al. (2017)：在资源受限平台上，不适合使用C++ future，因为其处理的不是单个事件而是事件流，因此在内存使用上是不确定的。

### 编程语言；C和C++

在当时，大部分嵌入式开发使用C和C++。使用C的比例在下降，C++在上升。

从C切换到C++的问题：

- 产生的机器码可能更大、更慢、可能内存布局不正确
- 代码可能更难进行最坏执行时间分析。

## 系统映射研究

### 文件搜索过程

**文件搜索过程的关键：搜索词、排除标准、选入标准。**

研究过程如下图所示：

![](../图片/屏幕截图%202024-11-12%20113901.png)

主要的选入标准（inclusion criterion）是在资源受限平台上的协程应用，不包括使用模拟器研究资源受限平台。（IC1）

排除标准（exclusion criteria）如下：

- 没有DOI或ISBN等学术标识符（EC1）
- 没有摘要（EC2）
- 在2007年以前发表（EC3）
- 不使用英语写作（EC4）
- 对综述者不可用（EC5）
- 是其它文章的更早版本（EC6）
- 不是主要研究（EC7）
- 不在所选的出版物类型范围内（EC8）

搜索词如下图：

![](../图片/屏幕截图%202024-11-12%20115233.png)

### 研究问题

![](../图片/屏幕截图%202024-11-15%20215115.png)

### 对研究有效性的威胁

威胁的三个来源：研究选择，数据提取，分类

研究选择：通过“滚雪球”（引入选中文献引用的文献）完善了搜索字符串，并证明了搜索字符串的连续性和一致性。

数据提取：在Excel里建立数据收集表单记录进度，增加可重复性和准确度，

分类：调研了部分文章的分类方式并比较

## 结果

### 概括

35篇相关文章，21篇描述了协程实现，使用了7种不同的编程语言

### 编程语言

- C：20/35
- 与C相关的语言（C++、NesC）：5/35
- Lua：4/35

### 协程实现

- 原生实现（不需要新增或修改工具链）：27/35

    其中，13/35使用宏（7/35使用Duff的方式），4/35使用库，3/35使用了`setjmp/longjmp`。

- 新增或修改工具链的实现

    其中，2/35实现了新语言，1/35实现语言扩展语法，2/35实现了转译器，1/35实现预编译器，1/35新增了一个编译优化阶段，2/35通过调用另一语言的功能实现协程。

### 结果图表

![](../图片/屏幕截图%202024-11-24%20212556.png)

![](../图片/屏幕截图%202024-11-24%20220644.png)

### 意图的优点

提及最多的优点是代码风格与间接性，因为协程就是为了解决回调函数的代码风格问题而提出的。

然而，协程在调度上的优势（协程提供了构造调度器的方式，而对于嵌入式设备等需要自己构造调度器的场合很有效）也是提及很多的优点，但它并未很好地在主流的桌面应用编程里反映。因此，语言方可能对这一点的关注不足。

## 分析和讨论

### API设计

![](../图片/屏幕截图%202024-11-24%20220938.png)

作者认为协程需要的功能：自动的控制流管理、自动的局部变量状态维护

![](../图片/屏幕截图%202024-11-24%20223327.png)

对于主流的桌面应用开发，使用堆空间保存协程状态很方便。但对于资源受限的嵌入式设备，则需要考虑采用栈或静态区保存。

### 研究缺口（Research Gap）

![](../图片/屏幕截图%202024-11-24%20223633.png)

大部分研究考虑了计算开销，却很少考虑与原有代码的适配。

### 可重复性

在一段时间间隔后使用同样的搜索词搜索各个数据库，比较两次搜索的结果差异。理想状况下，后一次搜索的结果应该是前一次搜索结果的超集。

### 讨论和总结

很多文章使用了基于Protothread的协程实现。

嵌入式设备上协程的用例：通信、数据流、传感器读数，都是原本使用回调方式，而现在可以使用协程改进实现的用例。

协程在嵌入式设备上的使用会更具挑战（资源限制，……），但带来的好处也更多（低开销调度、通信与传感器管理的更好支持）
