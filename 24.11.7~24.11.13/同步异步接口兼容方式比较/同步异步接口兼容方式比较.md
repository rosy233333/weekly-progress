# 同步异步接口兼容方式比较

时间：2024.11.12

## 比较指标

- 兼容性：对原有线程实现的支持情况
- 实现难度：为了新增协程支持，系统的修改量大小
- 迁移难度：为了从线程实现迁移到协程实现，用户程序的修改量大小
- 性能：暂时只能从理论层面分析该方式引入的性能开销

## 针对的情况

- 函数接口：普通的函数调用
- 系统调用接口：用户态请求内核态资源，涉及特权级切换
- trait接口：接口提供方提供trait并使用trait object，接口调用方实现trait。

## 函数接口

### 完全不进行接口统一，同步和异步使用各自的接口

兼容性：较高，因为原有的同步接口几乎没有修改

实现难度：中等，一方面不需要专门做接口统一，另一方面不统一的接口也会对协程支持的实现带来困难？

迁移难度：较高

性能：仅就接口而言没有引入开销，至于为系统添加协程支持引入的开销就和具体实现有关了。

### 使用不同名、相同参数、相同（形式）返回值、分别声明为async和非async的函数

兼容性：较高，一般会保留线程的各种接口

实现难度：中等，为协程实现与线程类似的任务调度接口较为简单，但为其它模块引入协程支持仍有一定工作量

迁移难度：中等

性能：仅就接口而言没有引入开销，至于为系统添加协程支持引入的开销就和具体实现有关了。

### zfl的方案：返回特殊Future的函数，可以用于同步或异步环境

兼容性：较高

实现难度：较高，可能还需修改线程已有的一些实现？

迁移难度：较低，因为线程和协程可以使用相同的函数

性能：对线程而言，有返回值的函数调用会进行一层包装，目前不清楚这层包装有没有开销。

## 系统调用接口

### zfl的方案：非阻塞系统调用

用户发起系统调用后，内核新建一个协程处理该系统调用，之后直接返回。用户程序若未得到结果则让出，直到获得系统返回的结果为止。未来还会实现对用户协程的唤醒机制。

兼容性：较高，调用方基本不需要修改。

实现难度：较高，需要以内核的协程化改造为前提。

迁移难度：较低，调用方基本不需要修改；然而，为了实现非阻塞的系统调用，调用方需要具有自己的用户态线程/协程库。

性能：多核情况下，可以降低特权级切换开销。

## trait接口

在目前的Rust版本中，带有async函数的trait是对象不安全的，无法进行动态分发。因此有一些解决该问题的方案：

### 使用智能指针封装Future返回值

实现难度：较低

迁移难度：较低，async trait的接口与sync trait类似。

性能：中等，堆分配引入了开销

### 使用StackFuture封装

实现难度：较低

迁移难度：较低

性能：较高，如果Future较小，可以放在栈上。否则，也需要分配堆空间

### 使用poll trait

实现难度：中等

迁移难度：中等（接口从async函数变为了poll函数，如果原本是手写的Future，则不需要修改；否则，可能需要将async函数转化为poll函数）

性能：高，不需要额外的堆分配

### 使用dynosaur，使用宏生成类似于动态分发的对象

实现难度：低

迁移难度：中等（trait的使用者要负责使用dynosau生成相应的对象）

性能：中等，需要堆分配

## 性能测试

### 对几种trait接口的测试

[测试记录](../../24.11.21~24.11.28/trait接口测试记录/trait接口测试记录.md)