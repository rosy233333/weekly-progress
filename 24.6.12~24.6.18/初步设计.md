# 初步设计

时间：2024/6/17

## 总述

该调度模块具有两个数据结构：（内置就绪队列的）调度器 `Scheduler` 和阻塞队列 `BlockQueue` 。使用泛型支持不同的任务类型 `T: /* 暂时未知的类型约束 */` 。

## `T`

`T` 类型代表被调度的任务。

### `run(&mut self)` 

运行该任务（该接口还未完全确定）

目前已知，该接口需要：

- 支持任务的初次运行/继续运行。从该任务上次暂停的位置开始（如果是第一次运行，则从任务的起始点开始）运行该任务，将执行流交给该任务。
- 支持任务的暂停/结束。保存任务的执行进度和上下文，将执行流交还给调度器。**注意，任务需要用一些方法告诉调度器应该如何处理暂停/结束后的自己，例如，是放回就绪队列、放入某个阻塞队列，还是释放掉？**

### 杂项

需要保证每个任务在内存中同时有且只有一个实例。如此，可以避免一些错误，例如任务同时被两个Scheduler运行，导致一致性被破坏。

## `Scheduler<T>`

调度器负责管理就绪和运行的任务，并且从中取出任务运行。

### `run(&mut self) -> !`

运行调度器，使其不断取出就绪队列中的任务并运行。

### `add<T>(&mut self, task: T)`

向调度器中加入任务。

### `current_task<T>(&self) -> &T`

获取调度器当前正在运行的任务。

该接口还未完全确定，主要是不确定获取的任务是什么形式，而且不知道会不会破坏“每个任务在内存中同时有且只有一个实例”的条件。

### `ready_tasks<T>(&self) -> &[&T]`

获取调度器中就绪的所有任务。

该接口还未完全确定，主要是不确定获取的任务是什么形式，而且不知道会不会破坏“每个任务在内存中同时有且只有一个实例”的条件。

## `BlockQueue<T>`

### `add<T>(&mut self, task: T)`

向阻塞队列中加入任务。

### `wake_one(&mut self)`

唤醒阻塞队列中的一个任务。

该接口还未完全确定，因为尚不清楚调度器和阻塞队列的关系，不知道阻塞队列如何将任务放入调度器中。

### `wake_all(&mut self)`

唤醒阻塞队列中的所有任务。

该接口还未完全确定，因为尚不清楚调度器和阻塞队列的关系，不知道阻塞队列如何将任务放入调度器中。

### `block_tasks<T>(&self) -> &[&T]`

获取阻塞队列中的所有任务。

该接口还未完全确定，主要是不确定获取的任务是什么形式，而且不知道会不会破坏“每个任务在内存中同时有且只有一个实例”的条件。

## 调度器和阻塞队列的关系

调度器的 `run` 方法可能将任务放入阻塞队列，阻塞队列的 `wake_one` 和 `wake_all` 方法会将任务放入调度器，因此调度器和阻塞队列需要具有某种联系。以使它们能获取到对方的实例。

在 ArceOS 中，阻塞队列可以在局部的作用域中创建，如该系统的 `Mutex` 内部包含一个阻塞队列。这与我们的设计存在冲突，因为当执行流返回调度器， `Mutex` 及其阻塞队列不再可用，从而导致调度器无法将任务放入 `Mutex` 的阻塞队列中。

因此，我目前计划将调度器和阻塞队列都创建在全局作用域和静态生命周期中。一些局部作用域中的对象，如 `Mutex` ，可以申请一个阻塞队列，并在使用完成后释放。可以设置一个类，如 `Runtime` ，来管理所有的调度器和阻塞队列。