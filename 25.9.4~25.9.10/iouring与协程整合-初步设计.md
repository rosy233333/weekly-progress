# iouring与协程整合-初步设计

## 队列结构变化

为了减少多方通信时创建队列的数量，将队列结构从SPSC改为MPSC，不再是每一对通信双方维护一组发送和接收队列，而是每一个进程（内核也算一个进程）维护自己的接收队列。

需要进行测试，以得知该变化能否带来性能增长。

## 任务队列与通信队列的统一，协程状态与IPC状态的统一

在此基础上，发现在发送异步IPC/系统调用的过程中，任务的状态变化与IPC信息的传递过程有相似之处：

```
任务放入阻塞队列 -----------------------> 任务放回就绪队列
请求放入对方接收队列 --> 接收方处理信息 --> 响应放回我方接收队列
```

因此，考虑统一任务就绪队列和IPC接收队列。

队列元素如下：

```Rust
pub struct Item {
    task: Task,
    block_on: Option<(Coroutine, usize)> // usize字段中存放pid
}

pub enum Task {
    IPCTask(IPCItem),
    Coroutine(Coroutine)
}

pub struct IPCItem {
    ipc_type: usize,
    ipc_params: [usize]
}
```

在协程运行过程中，该队列被协程运行时（executor）用作协程就绪队列。executor在循环中，取出一项`Item`，根据其类型执行相应操作：若类型为`IPCTask`，则唤醒已注册的相应IPC处理协程，并传入`block_on`作为发送方、`IPCItem`作为参数。若类型为`Coroutine`，则直接`poll`它。若将任务执行完毕（返回了`Ready`）且`block_on`有内容，则将返回值传递给`block_on`中正在阻塞的协程，并将它们放回各自的就绪队列。该过程既是**协程调度执行**的过程，又是**处理IPC、返回结果、唤醒发送方协程**的过程。

为了避免CPU的空转，若executor的就绪队列为空，它就会让出CPU给其它进程执行。如果一个CPU上的所有进程均没有就绪的协程，则CPU会进入低功耗模式。

当协程需要发送IPC时，它会构建一个类型为`IPCTask`的`Item`，其中包含自身进程id、IPC类型和参数，并将协程自身放入该`Item`的`block_on`中。将构建完成的`Item`放入接收方的队列中，自身返回`Pending`。这样就实现了**发送IPC**和**协程自身的阻塞**。

## 内核级任务的状态变化

以协程为基本任务单位时，内核级任务（进程或线程，以下全部用进程表示）的状态有以下几种：

- 运行
  - 就绪->运行：调度到该任务
- 就绪
  - 运行->就绪：时间片用完/被抢占/executor因为没有就绪协程而让出

进程不会阻塞。不过，需要提供一种机制，让进程调度器感知到“一个CPU上的所有进程均没有就绪协程”的情况，并使CPU休眠。

## 优先级与抢占

将IPC处理与任务调度统一后，如何进行优先级调度是一个问题。

对于协程而言，可以设定协程的优先级是在创建时确定且不会改变的。而IPC信息的优先级可以设定为发送方协程的优先级。这样，executor的就绪队列中的元素（协程/IPC消息）的优先级均为静态优先级，因此可以通过多条队列的方式实现优先级调度。

对于进程而言，可以设定进程的优先级是其中就绪的协程的最高优先级。因此，进程的优先级会动态变化。（如何实现动态优先级的调度队列还需进一步调研。关键问题例如，如何在一个进程已经在就绪队列中时改变它的优先级）。

可能出现两种抢占：进程级抢占和协程级抢占，分别在进程调度的级别和协程调度的级别上发生抢占。所有的抢占均可用中断实现，而且某些特殊场景下的抢占可以用让出实现。

在已有协程和进程优先级调度机制的基础上，可以得到进程优先级变化和需要抢占的场景：

- 创建高优先级协程：会改变当前进程的优先级。因此，不会触发进程级抢占，可能触发协程级抢占。而该协程级抢占可以通过创建协程后进行协程级让出来实现。
- 协程阻塞：当前协程阻塞后，executor取出下一协程执行，会改变自身的进程优先级。可能触发进程级抢占，且可以用进程级让出实现。
- IPC处理完成后，唤醒发送方的高优先级协程：会改变发送方的进程优先级，可能触发进程级和协程级抢占。如果发送方和接收方在同一个核心上，则进程级抢占可以用接收方进行进程级让出实现。

如果实现了优先级和抢占机制，则前文所述的“如果一个CPU上的所有进程均没有就绪的协程，则CPU会进入低功耗模式”机制可以通过优先级与抢占实现。在每个CPU上运行一个空闲任务，其优先级为第二低的优先级。空闲任务通过硬件指令等让CPU进入低功耗模式，并不会主动退出。如果executor取不出就绪的协程，则将自身进程的优先级设为最低并让出。因此，如果所有进程都没有就绪协程，则它们都被设置为最低优先级并让出，而进程调度器就会调度空闲任务执行。当该CPU上有协程被唤醒时，它会提高所在进程的优先级，从而触发进程级抢占，唤醒该CPU执行任务。

## 该设计的想法和问题

优势：

- 不需要单独的dispatcher协程进行IPC分发，可以使用executor同时进行协程和IPC的分发。同时避免了一个进程同时进行多个IPC通信时，创建多个dispatcher造成的资源浪费。
- 结合了中断方式和轮询方式的优势：
  - 不需要中断唤醒dispatcher协程，只有需要抢占时/需要唤醒CPU核心时才需要发送中断。减少了中断发送的频率，使更大的时间以轮询模式运行，因此具有轮询模式的高性能。
  - executor在目前没有就绪协程时让出CPU给其它进程；而CPU上的所有executor均没有就绪协程，则使CPU进行休眠。该机制基本实现了中断模式的多任务交替执行/低能耗的特点。
- 部分任务调度操作也可以包括进这个框架中，例如`yield`就是重新放回自身的就绪队列，`join`就是放入另一个协程的`block_on`。

问题：

- 安全问题
